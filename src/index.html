<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Tetris Well</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body>
<script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create well dimensions
    const cols = 5;      // well width in cells
    const rows = 5;      // well length in cells
    const depth = 12;    // well depth in cells
    const cellSize = 1;
    const wallHeight = depth * cellSize;

    const wellGroup = new THREE.Group();

    // Bottom grid lines in green
    const gridMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
    const gridGroup = new THREE.Group();
    for (let i = 0; i <= cols; i++) {
        const x = (i - cols / 2) * cellSize;
        const points = [
            new THREE.Vector3(x, 0, -rows * cellSize / 2),
            new THREE.Vector3(x, 0, rows * cellSize / 2)
        ];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, gridMaterial);
        gridGroup.add(line);
    }
    for (let j = 0; j <= rows; j++) {
        const z = (j - rows / 2) * cellSize;
        const points = [
            new THREE.Vector3(-cols * cellSize / 2, 0, z),
            new THREE.Vector3(cols * cellSize / 2, 0, z)
        ];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, gridMaterial);
        gridGroup.add(line);
    }
    wellGroup.add(gridGroup);

    // Add green grid lines on each wall
    function addWallGrid(width, height, constant, orientation) {
        // orientation: 'z' for planes parallel to X-Y at constant Z
        //              'x' for planes parallel to Z-Y at constant X
        for (let i = 0; i <= width; i++) {
            const offset = (i - width / 2) * cellSize;
            const points = orientation === 'z'
                ? [
                    new THREE.Vector3(offset, 0, constant),
                    new THREE.Vector3(offset, height, constant)
                  ]
                : [
                    new THREE.Vector3(constant, 0, offset),
                    new THREE.Vector3(constant, height, offset)
                  ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            gridGroup.add(new THREE.Line(geometry, gridMaterial));
        }
        for (let j = 0; j <= height / cellSize; j++) {
            const y = j * cellSize;
            const points = orientation === 'z'
                ? [
                    new THREE.Vector3(-width * cellSize / 2, y, constant),
                    new THREE.Vector3(width * cellSize / 2, y, constant)
                  ]
                : [
                    new THREE.Vector3(constant, y, -width * cellSize / 2),
                    new THREE.Vector3(constant, y, width * cellSize / 2)
                  ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            gridGroup.add(new THREE.Line(geometry, gridMaterial));
        }
    }

    // Back and front walls at constant z
    const backZ = -rows * cellSize / 2;
    const frontZ = rows * cellSize / 2;
    addWallGrid(cols, wallHeight, backZ, 'z');
    addWallGrid(cols, wallHeight, frontZ, 'z');

    // Left and right walls at constant x
    const leftX = -cols * cellSize / 2;
    const rightX = cols * cellSize / 2;
    addWallGrid(rows, wallHeight, leftX, 'x');
    addWallGrid(rows, wallHeight, rightX, 'x');

    scene.add(wellGroup);

    // Define a simple tetromino shape (T piece)
    const tShape = [
        [0, 0, 0],
        [1, 0, 0],
        [2, 0, 0],
        [1, 1, 0]
    ];

    function createTetromino(cells) {
        const group = new THREE.Group();
        const geom = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
        const edgeGeom = new THREE.EdgesGeometry(geom);
        const material = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 2 });
        cells.forEach(([x, y, z]) => {
            const edges = new THREE.LineSegments(edgeGeom, material);
            edges.position.set((x - 1.5) * cellSize + cellSize / 2, y * cellSize + cellSize / 2, (z - 0.5) * cellSize + cellSize / 2);
            group.add(edges);
        });
        return group;
    }

    const tetromino = createTetromino(tShape);
    tetromino.position.y = wallHeight - cellSize * 2;
    scene.add(tetromino);

    document.addEventListener('keydown', (event) => {
        switch (event.key) {
            case 'ArrowLeft':
                tetromino.rotation.y += Math.PI / 2;
                break;
            case 'ArrowRight':
                tetromino.rotation.y -= Math.PI / 2;
                break;
            case 'ArrowUp':
                tetromino.rotation.x += Math.PI / 2;
                break;
            case 'ArrowDown':
                tetromino.rotation.x -= Math.PI / 2;
                break;
        }
    });

    // Camera setup: perspective view from above the well
    camera.position.set(0, wallHeight * 1.5, 0);
    camera.up.set(0, 0, -1);
    camera.lookAt(0, 0, 0);

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    animate();

    // Handle resizing
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
