<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Tetris Well</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body>
<script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create well dimensions
    const cols = 5;      // well width in cells
    const rows = 5;      // well length in cells
    const depth = 12;    // well depth in cells
    const cellSize = 1;
    const wallHeight = depth * cellSize;

    const wellGroup = new THREE.Group();

    // Bottom grid lines in green
    const gridMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 });
    const gridGroup = new THREE.Group();
    for (let i = 0; i <= cols; i++) {
        const x = (i - cols / 2) * cellSize;
        const points = [
            new THREE.Vector3(x, 0, -rows * cellSize / 2),
            new THREE.Vector3(x, 0, rows * cellSize / 2)
        ];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, gridMaterial);
        gridGroup.add(line);
    }
    for (let j = 0; j <= rows; j++) {
        const z = (j - rows / 2) * cellSize;
        const points = [
            new THREE.Vector3(-cols * cellSize / 2, 0, z),
            new THREE.Vector3(cols * cellSize / 2, 0, z)
        ];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, gridMaterial);
        gridGroup.add(line);
    }
    wellGroup.add(gridGroup);

    // Add green grid lines on each wall
    function addWallGrid(width, height, constant, orientation) {
        // orientation: 'z' for planes parallel to X-Y at constant Z
        //              'x' for planes parallel to Z-Y at constant X
        for (let i = 0; i <= width; i++) {
            const offset = (i - width / 2) * cellSize;
            const points = orientation === 'z'
                ? [
                    new THREE.Vector3(offset, 0, constant),
                    new THREE.Vector3(offset, height, constant)
                  ]
                : [
                    new THREE.Vector3(constant, 0, offset),
                    new THREE.Vector3(constant, height, offset)
                  ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            gridGroup.add(new THREE.Line(geometry, gridMaterial));
        }
        for (let j = 0; j <= height / cellSize; j++) {
            const y = j * cellSize;
            const points = orientation === 'z'
                ? [
                    new THREE.Vector3(-width * cellSize / 2, y, constant),
                    new THREE.Vector3(width * cellSize / 2, y, constant)
                  ]
                : [
                    new THREE.Vector3(constant, y, -width * cellSize / 2),
                    new THREE.Vector3(constant, y, width * cellSize / 2)
                  ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            gridGroup.add(new THREE.Line(geometry, gridMaterial));
        }
    }

    // Back and front walls at constant z
    const backZ = -rows * cellSize / 2;
    const frontZ = rows * cellSize / 2;
    addWallGrid(cols, wallHeight, backZ, 'z');
    addWallGrid(cols, wallHeight, frontZ, 'z');

    // Left and right walls at constant x
    const leftX = -cols * cellSize / 2;
    const rightX = cols * cellSize / 2;
    addWallGrid(rows, wallHeight, leftX, 'x');
    addWallGrid(rows, wallHeight, rightX, 'x');

    scene.add(wellGroup);

    // Tetromino data (T shape). Coordinates are relative to the piece pivot at the origin.
    const tShape = [
        new THREE.Vector3(-1, 0, 0),
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(1, 0, 0),
        new THREE.Vector3(0, 1, 0)
    ];

    function createTetromino(cells) {
        const group = new THREE.Group();
        const geom = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
        const mat = new THREE.MeshBasicMaterial({
            color: 0x0000ff,
            transparent: true,
            opacity: 0.5
        });
        const edgeGeom = new THREE.EdgesGeometry(geom);
        const edgeMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
        const cubes = [];
        cells.forEach(() => {
            const mesh = new THREE.Mesh(geom, mat);
            const edges = new THREE.LineSegments(edgeGeom, edgeMat);
            mesh.add(edges);
            group.add(mesh);
            cubes.push(mesh);
        });
        return { group, cubes, material: mat };
    }

    const { group: tetromino, cubes, material: tetrominoMaterial } = createTetromino(tShape);

    // Position of the piece pivot in grid coordinates
    const tetrominoPos = new THREE.Vector3(Math.floor(cols / 2), depth - 2, Math.floor(rows / 2));
    let tetrominoCells = tShape.map(v => v.clone());
    let hasLanded = false;

    scene.add(tetromino);

    function updateTetromino() {
        for (let i = 0; i < cubes.length; i++) {
            const c = tetrominoCells[i];
            cubes[i].position.set(
                (tetrominoPos.x + c.x - cols / 2 + 0.5) * cellSize,
                (tetrominoPos.y + c.y + 0.5) * cellSize,
                (tetrominoPos.z + c.z - rows / 2 + 0.5) * cellSize
            );
        }
    }

    function dropPiece() {
        if (hasLanded) return;
        tetrominoPos.y -= 1;
        if (!insideBounds(tetrominoPos, tetrominoCells)) {
            tetrominoPos.y += 1;
            hasLanded = true;
            tetrominoMaterial.opacity = 1.0; // 0% transparency
            clearInterval(dropTimer);
        }
        updateTetromino();
    }

    const dropTimer = setInterval(dropPiece, 2000);

    function insideBounds(pos, cells) {
        for (const c of cells) {
            const x = pos.x + c.x;
            const y = pos.y + c.y;
            const z = pos.z + c.z;
            if (x < 0 || x >= cols || z < 0 || z >= rows || y < 0 || y >= depth) {
                return false;
            }
        }
        return true;
    }

    function rotateX(dir) {
        tetrominoCells = tetrominoCells.map(v => new THREE.Vector3(
            v.x,
            dir > 0 ? -v.z : v.z,
            dir > 0 ? v.y : -v.y
        ));
    }

    function rotateY(dir) {
        tetrominoCells = tetrominoCells.map(v => new THREE.Vector3(
            dir > 0 ? v.z : -v.z,
            v.y,
            dir > 0 ? -v.x : v.x
        ));
    }

    updateTetromino();

    document.addEventListener('keydown', (event) => {
        const key = event.key.toLowerCase();
        const oldPos = tetrominoPos.clone();
        const oldCells = tetrominoCells.map(v => v.clone());
        switch (key) {
            case 'arrowleft':
                tetrominoPos.x -= 1;
                break;
            case 'arrowright':
                tetrominoPos.x += 1;
                break;
            case 'arrowup':
                tetrominoPos.z -= 1;
                break;
            case 'arrowdown':
                tetrominoPos.z += 1;
                break;
            case 'a':
                rotateY(1);
                break;
            case 'd':
                rotateY(-1);
                break;
            case 'w':
                rotateX(1);
                break;
            case 's':
                rotateX(-1);
                break;
            default:
                return;
        }
        if (!insideBounds(tetrominoPos, tetrominoCells)) {
            tetrominoPos.copy(oldPos);
            tetrominoCells = oldCells;
        }
        updateTetromino();
    });

    // Camera setup: perspective view from above the well
    camera.position.set(0, wallHeight * 1.5, 0);
    camera.up.set(0, 0, -1);
    camera.lookAt(0, 0, 0);

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    animate();

    // Handle resizing
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
