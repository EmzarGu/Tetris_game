<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Tetris Well</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body>
<script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create well dimensions
    const cols = 10;
    const rows = 20;
    const cellSize = 1;
    const wallThickness = 0.1;
    const wallHeight = 10;

    const wellGroup = new THREE.Group();

    // Bottom grid lines in green
    const gridHelper = new THREE.GridHelper(cols * cellSize, cols, 0x00ff00, 0x00ff00);
    gridHelper.position.y = 0;
    gridHelper.scale.z = rows / cols;
    wellGroup.add(gridHelper);

    // Create wireframe walls without colors
    const wallMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
    const wallGeo1 = new THREE.BoxGeometry(cols * cellSize + wallThickness*2, wallHeight, wallThickness);
    const wallGeo2 = new THREE.BoxGeometry(wallThickness, wallHeight, rows * cellSize);

    // Back and front walls
    const backWall = new THREE.Mesh(wallGeo1, wallMaterial);
    backWall.position.z = -rows*cellSize/2 - wallThickness/2;
    backWall.position.y = wallHeight/2;
    wellGroup.add(backWall);

    const frontWall = new THREE.Mesh(wallGeo1, wallMaterial);
    frontWall.position.z = rows*cellSize/2 + wallThickness/2;
    frontWall.position.y = wallHeight/2;
    wellGroup.add(frontWall);

    // Left and right walls
    const leftWall = new THREE.Mesh(wallGeo2, wallMaterial);
    leftWall.position.x = -cols*cellSize/2 - wallThickness/2;
    leftWall.position.y = wallHeight/2;
    wellGroup.add(leftWall);

    const rightWall = new THREE.Mesh(wallGeo2, wallMaterial);
    rightWall.position.x = cols*cellSize/2 + wallThickness/2;
    rightWall.position.y = wallHeight/2;
    wellGroup.add(rightWall);

    scene.add(wellGroup);

    // Game grid tracks occupied cells
    const gridHeight = Math.floor(wallHeight / cellSize);
    const grid = [];
    for (let y = 0; y < gridHeight; y++) {
        grid[y] = Array(cols).fill(false);
    }

    let activePiece = null;
    let gameOver = false;
    const dropInterval = 500; // ms between automatic drops
    let lastDrop = 0;

    function gridToWorld(x, y) {
        return new THREE.Vector3(
            (x - cols / 2 + 0.5) * cellSize,
            y * cellSize + cellSize / 2,
            0
        );
    }

    function createPiece() {
        const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const startX = Math.floor(cols / 2);
        const startY = gridHeight - 1;
        if (grid[startY][startX]) {
            gameOver = true;
            return null;
        }
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(gridToWorld(startX, startY));
        scene.add(mesh);
        activePiece = { mesh, x: startX, y: startY };
        return activePiece;
    }

    function dropActivePiece() {
        if (!activePiece || gameOver) return;
        const nextY = activePiece.y - 1;
        if (nextY < 0 || grid[nextY][activePiece.x]) {
            // lock the piece in place
            grid[activePiece.y][activePiece.x] = true;
            activePiece.mesh.material.color.set(0x800080);
            activePiece = null;
            createPiece();
            return;
        }
        activePiece.y = nextY;
        activePiece.mesh.position.copy(gridToWorld(activePiece.x, activePiece.y));
    }

    document.addEventListener('keydown', (e) => {
        if (!activePiece || gameOver) return;
        if (e.key === 'ArrowLeft') {
            const nextX = activePiece.x - 1;
            if (nextX >= 0 && !grid[activePiece.y][nextX]) {
                activePiece.x = nextX;
                activePiece.mesh.position.copy(gridToWorld(activePiece.x, activePiece.y));
            }
        } else if (e.key === 'ArrowRight') {
            const nextX = activePiece.x + 1;
            if (nextX < cols && !grid[activePiece.y][nextX]) {
                activePiece.x = nextX;
                activePiece.mesh.position.copy(gridToWorld(activePiece.x, activePiece.y));
            }
        }
    });

    createPiece();

    // Camera setup: perspective view from above
    camera.position.set(0, 20, 20);
    camera.lookAt(0, 0, 0);

    function animate(time) {
        requestAnimationFrame(animate);
        if (!gameOver && time - lastDrop > dropInterval) {
            dropActivePiece();
            lastDrop = time;
        }
        renderer.render(scene, camera);
    }

    animate();

    // Handle resizing
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
